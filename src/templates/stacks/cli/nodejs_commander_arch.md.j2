# Node.js CLI Architecture (Commander)

## ðŸ—ï¸ High-Level Overview

This project is a Command Line Interface (CLI) tool built with **Node.js** and **Commander.js**.
It uses **ES Modules** natively and follows the **Command Pattern** to organize sub-commands.

## ðŸ“‚ Directory Structure

```text
root/
â”œâ”€â”€ bin/
â”‚   â””â”€â”€ cli.js           # Executable Entry Point (Shebang)
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main.js          # Commander program definition
â”‚   â”œâ”€â”€ commands/        # Command modules
â”‚   â”‚   â”œâ”€â”€ init.js      # e.g., 'mycli init'
â”‚   â”‚   â””â”€â”€ build.js     # e.g., 'mycli build'
â”‚   â”œâ”€â”€ lib/             # Core Business Logic (Testable)
â”‚   â”œâ”€â”€ utils/           # Shared Helpers (Logger, Config)
â”‚   â””â”€â”€ prompts/         # Interactive prompts definitions
â”œâ”€â”€ package.json         # "bin" configuration
â””â”€â”€ README.md
```

## ðŸ§© Key Architectural Patterns

### 1. The Entry Point (`bin/cli.js`)
- Contains the `#!/usr/bin/env node` shebang.
- Purely imports the app and executes it.
- **Rule:** No business logic here. Just a shim to bootstrap the runtime.

### 2. Command Modules
We avoid defining all commands in a single huge file.
- Each command resides in `src/commands/`.
- It exports a function that takes the `program` instance and registers itself.

```javascript
// src/commands/build.js
export function registerBuildCommand(program) {
  program
    .command('build')
    .description('Build the project')
    .action(async (options) => { ... });
}
```

### 3. Logic Separation (Actions vs. Lib)
- **Action Handlers:** Handle CLI-specific concerns (parsing options, printing colors, showing spinners).
- **Lib/Service:** Pure functions that do the actual work (file manipulation, API calls).
- **Benefit:** You can test the `Lib` functions without mocking CLI inputs.

{% if "Inquirer" in libraries %}
### 4. Interactive Mode (Prompts)
- If required arguments are missing, the CLI prompts the user via **Inquirer**.
- Prompt logic is encapsulated in `src/prompts/` to keep command files clean.
{% endif %}

{% if "Figlet" in libraries %}
### 5. Branding
- Upon initialization (or help command), **Figlet** is used to display the ASCII logo of the tool.
{% endif %}

## ðŸ’¾ Configuration Management
- CLI tools often need persistent config (e.g., API keys).
- We typically store this in the user's home directory (`~/.config/{{ project_name }}/config.json`) using tools like `conf` or `dot-json`.

## ðŸ“¦ Distribution
- The project is configured to be installed via `npm install -g`.
- The `bin` field in `package.json` maps the command name to `bin/cli.js`.