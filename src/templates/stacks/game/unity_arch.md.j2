# Unity Project Architecture

## ðŸ—ï¸ High-Level Overview

This project is built using **Unity 2023 LTS+ (Unity 6)**.
It follows a **Modular Monolith** approach using **Assembly Definitions (.asmdef)** to enforce separation of concerns and reduce compilation time.

**Core Philosophy:**
- **Data over Logic:** Game configuration lives in **ScriptableObjects**, not hardcoded in scripts.
- **Events over Coupling:** Systems communicate via **C# Events** or **ScriptableObject Channels**, minimizing direct dependencies.

## ðŸ“‚ Directory Structure

We use the underscore `_` prefix for root directories that we modify frequently, keeping them at the top of the Project view.

```text
Assets/
â”œâ”€â”€ _Game/               # Core Game Logic
â”‚   â”œâ”€â”€ Scripts/
â”‚   â”‚   â”œâ”€â”€ Core/        # Managers (GameManager, AudioService)
â”‚   â”‚   â”œâ”€â”€ Gameplay/    # Mechanics (Player, Weapons)
â”‚   â”‚   â”œâ”€â”€ UI/          # UI Logic
â”‚   â”‚   â””â”€â”€ Utils/       # Helpers
â”‚   â”œâ”€â”€ Scenes/          # Scene Files
â”‚   â””â”€â”€ Settings/        # ScriptableObject Instances (GameConfig)
â”œâ”€â”€ _Art/                # Art Assets (Models, Textures, Animations)
â”œâ”€â”€ _Audio/              # Sound Clips
â”œâ”€â”€ Plugins/             # 3rd Party SDKs
â”œâ”€â”€ Resources/           # (Avoid using unless strictly necessary)
â””â”€â”€ Settings/            # Input System & Render Pipeline Settings
```

## ðŸ§© Key Architectural Patterns

### 1. ScriptableObject Architecture
We heavily utilize **ScriptableObjects** (SO) for:
- **Game Configuration:** Player stats, Enemy definitions.
- **Event Channels:** Observer pattern where a sender raises an SO event, and listeners respond.
- **Runtime Sets:** Tracking active objects (e.g., "All Active Enemies") without `FindObjectsOfType`.

### 2. Assembly Definitions (.asmdef)
Code is split into Assemblies to enforce dependencies:
- `Core.asmdef`: No dependencies.
- `Gameplay.asmdef`: Depends on `Core`.
- `UI.asmdef`: Depends on `Core` and `Gameplay`.
- **Benefit:** Changing UI code doesn't recompile the Physics engine logic.

### 3. Manager Pattern (Service Locator)
- We use a central `ServiceLocator` or `GameManager` (Singleton) for global systems (Audio, SaveSystem).
- **Rule:** Singletons should strictly be for "Systems", not for Gameplay logic (e.g., Player should not be a Singleton).

{% if libraries | default([]) | select("in", ["Input System"]) | list | length > 0 %}
### 4. Input System
- We use the **New Input System** package.
- Input is handled via **Input Actions** assets, not direct polling.
- Use `PlayerInput` component or generated C# class for type-safe events.
{% endif %}

{% if libraries | default([]) | select("in", ["Addressables"]) | list | length > 0 %}
### 5. Asset Management (Addressables)
- We strictly avoid `Resources.Load`.
- Assets are marked as **Addressable** and loaded asynchronously.
- Memory management is manual: call `Release()` on handles when done.
{% endif %}

## ðŸ’¾ Data Persistence
- **JsonUtility / Newtonsoft:** For serialization.
- **Save Path:** `Application.persistentDataPath`.
- **Strategy:** Separation between *Runtime Data* (C# Classes) and *Serialized Data* (JSON). The SaveSystem mediates between them.