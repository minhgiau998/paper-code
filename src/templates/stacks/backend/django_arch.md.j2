# Django Project Architecture

## ðŸ—ï¸ High-Level Overview

This project is built using **Django 5+**.
{% if libraries | default([]) | select("in", ["Django REST Framework"]) | list | length > 0 %}
It acts primarily as a backend API using **Django REST Framework (DRF)**.
{% else %}
It follows the standard MTV (Model-Template-View) pattern with server-side rendering.
{% endif %}

We deviate from the default "startproject" structure to a more scalable, domain-driven layout using a dedicated `apps/` directory and split settings.

## ðŸ“‚ Directory Structure

```text
root/
â”œâ”€â”€ manage.py            # CLI entry point
â”œâ”€â”€ config/              # Project configuration (formerly 'project_name')
â”‚   â”œâ”€â”€ settings/        # Split settings
â”‚   â”‚   â”œâ”€â”€ base.py      # Common settings
â”‚   â”‚   â”œâ”€â”€ local.py     # Dev settings
â”‚   â”‚   â””â”€â”€ production.py
â”‚   â”œâ”€â”€ urls.py          # Root URLconf
â”‚   â”œâ”€â”€ wsgi.py
â”‚   â””â”€â”€ asgi.py          # Async entry point
â”œâ”€â”€ apps/                # Domain Logic (Local Apps)
â”‚   â”œâ”€â”€ common/          # Shared utilities/models
â”‚   â”œâ”€â”€ users/           # User domain
â”‚   â”‚   â”œâ”€â”€ api/         # DRF Views/Serializers
â”‚   â”‚   â”œâ”€â”€ models.py
â”‚   â”‚   â””â”€â”€ services.py  # Business Logic
â”‚   â””â”€â”€ core/
â”œâ”€â”€ requirements/        # Dependency management
â””â”€â”€ tests/               # Global test suite
```

## ðŸ§© Key Architectural Patterns

### 1. The "Apps" Directory
- All local Django applications live inside the `apps/` folder.
- This keeps the root directory clean and separates business logic from configuration.
- Update `sys.path` in `manage.py` and `config/settings/base.py` to recognize `apps/`.

### 2. Service Layer (Business Logic)
We prefer the **Service Layer** pattern over putting too much logic in Models ("Fat Models") or Views.
- **Views/ViewSets:** Handle HTTP request/response, permission checks, and data serialization.
- **Services (`services.py`):** Pure Python functions/classes that handle the actual business rules (e.g., `create_user`, `process_payment`).
- **Models:** Define schema and simple data-integrity methods.

{% if libraries | default([]) | select("in", ["Django REST Framework"]) | list | length > 0 %}
### 3. API Architecture (DRF)
- **ViewSets:** Prefer `ModelViewSet` or `GenericViewSet` for standard CRUD to reduce boilerplate.
- **Serializers:** strictly used for Input Validation and Output Formatting.
- **Routers:** Use `DefaultRouter` or `SimpleRouter` for automatic URL wiring.
{% endif %}

{% if libraries | default([]) | select("in", ["Celery"]) | list | length > 0 %}
### 4. Asynchronous Tasks (Celery)
- Use **Celery** for long-running tasks (Email, Reports, Image Processing).
- Define tasks in `apps/<app_name>/tasks.py`.
- **Do not** execute heavy queries or external API calls inside the HTTP request-response cycle.
{% endif %}

### 5. Settings Management
- **Never** use a single `settings.py` for everything.
- Use environment variables (via `python-dotenv` or `django-environ`) to load secrets in `config/settings/base.py`.

## ðŸ”’ Security Architecture
- **User Model:** Always use a custom user model (`AUTH_USER_MODEL`) defined in `apps/users`.
- **Secret Key:** Never commit the secret key. Load it from `.env`.
- **CORS:** Explicitly whitelist origins if building an API.