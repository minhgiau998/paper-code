# Winston Documentation

> **Purpose:** A simple and universal logging library with support for multiple transports.

## ðŸ“¦ Installation

```bash
npm install winston
# Optional transports
npm install winston-daily-rotate-file
npm install @elastic/elasticsearch
npm install nodemailer
npm install winston-mongodb
```

## ðŸ› ï¸ Basic Configuration

**Strategy:** Use structured logging with multiple transports and proper log levels.

### 1. Logger Configuration (`src/config/logger.js`)

```javascript
const winston = require('winston');
const DailyRotateFile = require('winston-daily-rotate-file');
const { ElasticsearchTransport } = require('winston-elasticsearch');
const MongoDB = require('winston-mongodb');

// Custom log format
const logFormat = winston.format.combine(
  winston.format.timestamp({
    format: 'YYYY-MM-DD HH:mm:ss',
  }),
  winston.format.errors({ stack: true }),
  winston.format.json(),
  winston.format.printf(({ timestamp, level, message, stack, ...meta }) => {
    let log = `${timestamp} [${level.toUpperCase()}]: ${message}`;
    
    if (Object.keys(meta).length > 0) {
      log += ` ${JSON.stringify(meta)}`;
    }
    
    if (stack) {
      log += `\n${stack}`;
    }
    
    return log;
  })
);

// Console format for development
const consoleFormat = winston.format.combine(
  winston.format.colorize(),
  winston.format.timestamp({
    format: 'HH:mm:ss',
  }),
  winston.format.printf(({ timestamp, level, message, stack, ...meta }) => {
    let log = `${timestamp} ${level}: ${message}`;
    
    if (Object.keys(meta).length > 0) {
      log += ` ${JSON.stringify(meta, null, 2)}`;
    }
    
    if (stack) {
      log += `\n${stack}`;
    }
    
    return log;
  })
);

// Create transports array
const transports = [];

// Console transport (always included)
transports.push(
  new winston.transports.Console({
    level: process.env.LOG_LEVEL || 'info',
    format: process.env.NODE_ENV === 'production' ? logFormat : consoleFormat,
  })
);

// File transport for production
if (process.env.NODE_ENV === 'production') {
  // Daily rotating file transport
  transports.push(
    new DailyRotateFile({
      filename: 'logs/application-%DATE%.log',
      datePattern: 'YYYY-MM-DD',
      zippedArchive: true,
      maxSize: '20m',
      maxFiles: '14d',
      level: 'info',
      format: logFormat,
    })
  );

  // Error log file
  transports.push(
    new DailyRotateFile({
      filename: 'logs/error-%DATE%.log',
      datePattern: 'YYYY-MM-DD',
      zippedArchive: true,
      maxSize: '20m',
      maxFiles: '30d',
      level: 'error',
      format: logFormat,
    })
  );
}

// Elasticsearch transport (optional)
if (process.env.ELASTICSEARCH_URL) {
  transports.push(
    new ElasticsearchTransport({
      level: 'info',
      clientOpts: {
        node: process.env.ELASTICSEARCH_URL,
      },
      index: 'application-logs',
      transformer: (logData) => {
        return {
          '@timestamp': new Date().toISOString(),
          level: logData.level,
          message: logData.message,
          meta: logData.meta,
          stack: logData.stack,
        };
      },
    })
  );
}

// MongoDB transport (optional)
if (process.env.MONGODB_LOG_URL) {
  transports.push(
    new MongoDB({
      level: 'info',
      db: process.env.MONGODB_LOG_URL,
      collection: 'logs',
      format: logFormat,
      tryReconnect: true,
    })
  );
}

// Create logger instance
const logger = winston.createLogger({
  level: process.env.LOG_LEVEL || 'info',
  format: logFormat,
  transports,
  exitOnError: false,
  // Handle uncaught exceptions
  exceptionHandlers: [
    new winston.transports.File({ 
      filename: 'logs/exceptions.log',
      format: logFormat,
    }),
  ],
  // Handle unhandled promise rejections
  rejectionHandlers: [
    new winston.transports.File({ 
      filename: 'logs/rejections.log',
      format: logFormat,
    }),
  ],
});

// Add request context middleware
logger.addContext = (req) => {
  logger.defaultMeta = {
    requestId: req.id || 'unknown',
    method: req.method,
    url: req.url,
    ip: req.ip || req.connection.remoteAddress,
    userAgent: req.get('User-Agent'),
  };
};

// Clear request context
logger.clearContext = () => {
  logger.defaultMeta = {};
};

module.exports = logger;
```

### 2. Logger Service (`src/services/loggerService.js`)

```javascript
const logger = require('../config/logger');

class LoggerService {
  constructor() {
    this.context = {};
  }

  // Set context for all subsequent logs
  setContext(context) {
    this.context = { ...this.context, ...context };
  }

  // Clear context
  clearContext() {
    this.context = {};
  }

  // Log with context
  log(level, message, meta = {}) {
    logger.log(level, message, { ...this.context, ...meta });
  }

  // Convenience methods
  debug(message, meta = {}) {
    this.log('debug', message, meta);
  }

  info(message, meta = {}) {
    this.log('info', message, meta);
  }

  warn(message, meta = {}) {
    this.log('warn', message, meta);
  }

  error(message, error = null, meta = {}) {
    const errorMeta = {
      ...this.context,
      ...meta,
    };

    if (error) {
      errorMeta.error = {
        message: error.message,
        stack: error.stack,
        name: error.name,
      };
    }

    this.log('error', message, errorMeta);
  }

  // HTTP request logging
  logRequest(req, res, responseTime) {
    const logData = {
      method: req.method,
      url: req.url,
      statusCode: res.statusCode,
      responseTime: `${responseTime}ms`,
      userAgent: req.get('User-Agent'),
      ip: req.ip || req.connection.remoteAddress,
      contentLength: res.get('Content-Length'),
    };

    if (res.statusCode >= 400) {
      this.warn(`HTTP ${res.statusCode} - ${req.method} ${req.url}`, logData);
    } else {
      this.info(`HTTP ${res.statusCode} - ${req.method} ${req.url}`, logData);
    }
  }

  // Database operation logging
  logDatabase(operation, table, duration, error = null) {
    const logData = {
      operation,
      table,
      duration: `${duration}ms`,
    };

    if (error) {
      this.error(`Database ${operation} failed on ${table}`, error, logData);
    } else {
      this.debug(`Database ${operation} completed on ${table}`, logData);
    }
  }

  // Authentication logging
  logAuth(action, userId, success = true, ip = null) {
    const logData = {
      action,
      userId,
      success,
      ip,
    };

    if (success) {
      this.info(`Auth ${action} successful`, logData);
    } else {
      this.warn(`Auth ${action} failed`, logData);
    }
  }

  // Business logic logging
  logBusiness(event, data = {}) {
    this.info(`Business event: ${event}`, { event, ...data });
  }

  // Performance logging
  logPerformance(operation, duration, metadata = {}) {
    const logData = {
      operation,
      duration: `${duration}ms`,
      ...metadata,
    };

    if (duration > 1000) {
      this.warn(`Slow operation: ${operation}`, logData);
    } else {
      this.debug(`Performance: ${operation}`, logData);
    }
  }

  // Security logging
  logSecurity(event, severity = 'medium', data = {}) {
    const logData = {
      securityEvent: event,
      severity,
      ...data,
    };

    if (severity === 'high') {
      this.error(`Security event: ${event}`, logData);
    } else if (severity === 'medium') {
      this.warn(`Security event: ${event}`, logData);
    } else {
      this.info(`Security event: ${event}`, logData);
    }
  }

  // API logging
  logApiCall(method, endpoint, userId, statusCode, duration) {
    const logData = {
      method,
      endpoint,
      userId,
      statusCode,
      duration: `${duration}ms`,
    };

    if (statusCode >= 400) {
      this.warn(`API call failed: ${method} ${endpoint}`, logData);
    } else {
      this.info(`API call: ${method} ${endpoint}`, logData);
    }
  }

  // Background job logging
  logJob(jobName, status, duration = null, error = null) {
    const logData = {
      jobName,
      status,
      duration: duration ? `${duration}ms` : null,
    };

    if (status === 'completed') {
      this.info(`Job completed: ${jobName}`, logData);
    } else if (status === 'failed') {
      this.error(`Job failed: ${jobName}`, error, logData);
    } else {
      this.info(`Job ${status}: ${jobName}`, logData);
    }
  }
}

module.exports = new LoggerService();
```

## ðŸ”§ Express Middleware

### 1. Request Logging Middleware (`src/middleware/logger.js`)

```javascript
const loggerService = require('../services/loggerService');

const requestLogger = (req, res, next) => {
  const start = Date.now();
  
  // Generate unique request ID
  req.id = `req_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  
  // Set logger context
  loggerService.setContext({
    requestId: req.id,
    method: req.method,
    url: req.url,
    ip: req.ip || req.connection.remoteAddress,
    userAgent: req.get('User-Agent'),
  });

  // Log request
  loggerService.info('Incoming request', {
    method: req.method,
    url: req.url,
    headers: req.headers,
    query: req.query,
    body: req.body,
  });

  // Override res.end to log response
  const originalEnd = res.end;
  res.end = function(chunk, encoding) {
    const duration = Date.now() - start;
    
    // Log response
    loggerService.logRequest(req, res, duration);
    
    // Clear context
    loggerService.clearContext();
    
    // Call original end
    originalEnd.call(this, chunk, encoding);
  };

  next();
};

module.exports = requestLogger;
```

### 2. Error Logging Middleware (`src/middleware/errorLogger.js`)

```javascript
const loggerService = require('../services/loggerService');

const errorLogger = (err, req, res, next) => {
  // Log error with request context
  loggerService.error('Unhandled error occurred', err, {
    method: req.method,
    url: req.url,
    headers: req.headers,
    query: req.query,
    body: req.body,
    ip: req.ip || req.connection.remoteAddress,
    userAgent: req.get('User-Agent'),
  });

  next(err);
};

module.exports = errorLogger;
```

## ðŸš€ Usage Examples

### 1. Basic Usage (`src/controllers/userController.js`)

```javascript
const loggerService = require('../services/loggerService');

class UserController {
  async createUser(req, res) {
    try {
      const startTime = Date.now();
      
      loggerService.info('Creating new user', {
        email: req.body.email,
        name: req.body.name,
      });

      const user = await userService.create(req.body);
      
      const duration = Date.now() - startTime;
      loggerService.logPerformance('create_user', duration, { userId: user.id });
      
      loggerService.logBusiness('user_created', {
        userId: user.id,
        email: user.email,
      });

      res.status(201).json(user);
    } catch (error) {
      loggerService.error('Failed to create user', error, {
        email: req.body.email,
      });
      
      res.status(500).json({ error: 'Failed to create user' });
    }
  }

  async loginUser(req, res) {
    try {
      const { email, password } = req.body;
      
      loggerService.info('User login attempt', {
        email,
        ip: req.ip,
      });

      const user = await authService.login(email, password);
      
      if (user) {
        loggerService.logAuth('login', user.id, true, req.ip);
        loggerService.logBusiness('user_logged_in', {
          userId: user.id,
          email: user.email,
        });
        
        res.json({ token: user.token });
      } else {
        loggerService.logAuth('login', email, false, req.ip);
        loggerService.logSecurity('failed_login', 'medium', {
          email,
          ip: req.ip,
        });
        
        res.status(401).json({ error: 'Invalid credentials' });
      }
    } catch (error) {
      loggerService.error('Login error', error, {
        email: req.body.email,
        ip: req.ip,
      });
      
      res.status(500).json({ error: 'Login failed' });
    }
  }
}
```

### 2. Database Logging (`src/services/databaseService.js`)

```javascript
const loggerService = require('./loggerService');

class DatabaseService {
  async query(sql, params = []) {
    const startTime = Date.now();
    
    try {
      const result = await this.pool.query(sql, params);
      const duration = Date.now() - startTime;
      
      loggerService.logDatabase('query', 'unknown', duration);
      loggerService.debug('Database query executed', {
        sql: sql.substring(0, 100) + '...',
        rowCount: result.rowCount,
      });
      
      return result;
    } catch (error) {
      const duration = Date.now() - startTime;
      
      loggerService.logDatabase('query', 'unknown', duration, error);
      loggerService.error('Database query failed', error, {
        sql: sql.substring(0, 100) + '...',
      });
      
      throw error;
    }
  }

  async transaction(queries) {
    const startTime = Date.now();
    
    try {
      const client = await this.pool.connect();
      
      try {
        await client.query('BEGIN');
        
        const results = [];
        for (const { sql, params } of queries) {
          const result = await client.query(sql, params);
          results.push(result);
        }
        
        await client.query('COMMIT');
        
        const duration = Date.now() - startTime;
        loggerService.logDatabase('transaction', 'unknown', duration);
        loggerService.info('Transaction completed successfully', {
          queryCount: queries.length,
        });
        
        return results;
      } catch (error) {
        await client.query('ROLLBACK');
        
        const duration = Date.now() - startTime;
        loggerService.logDatabase('transaction', 'unknown', duration, error);
        loggerService.error('Transaction failed', error, {
          queryCount: queries.length,
        });
        
        throw error;
      } finally {
        client.release();
      }
    } catch (error) {
      const duration = Date.now() - startTime;
      loggerService.logDatabase('transaction', 'unknown', duration, error);
      throw error;
    }
  }
}
```

### 3. Background Job Logging (`src/jobs/emailJob.js`)

```javascript
const loggerService = require('../services/loggerService');

class EmailJob {
  async process(job) {
    const startTime = Date.now();
    
    try {
      loggerService.logJob('email_send', 'started', null, null, {
        jobId: job.id,
        recipient: job.data.recipient,
        template: job.data.template,
      });

      await this.sendEmail(job.data);
      
      const duration = Date.now() - startTime;
      loggerService.logJob('email_send', 'completed', duration);
      
      loggerService.logBusiness('email_sent', {
        jobId: job.id,
        recipient: job.data.recipient,
        template: job.data.template,
      });
      
    } catch (error) {
      const duration = Date.now() - startTime;
      loggerService.logJob('email_send', 'failed', duration, error);
      
      throw error;
    }
  }

  async sendEmail(data) {
    // Email sending logic
    loggerService.info('Sending email', {
      recipient: data.recipient,
      subject: data.subject,
      template: data.template,
    });

    // Simulate email sending
    await new Promise(resolve => setTimeout(resolve, 1000));
    
    loggerService.info('Email sent successfully', {
      recipient: data.recipient,
    });
  }
}
```

## ðŸ”„ Integration with Frameworks

### 1. Express Integration (`src/app.js`)

```javascript
const express = require('express');
const requestLogger = require('./middleware/logger');
const errorLogger = require('./middleware/errorLogger');

const app = express();

// Add request logging middleware
app.use(requestLogger);

// Add error logging middleware (should be last)
app.use(errorLogger);

// Your routes here...

// Global error handler
app.use((err, req, res, next) => {
  loggerService.error('Unhandled error', err, {
    method: req.method,
    url: req.url,
    ip: req.ip,
  });
  
  res.status(500).json({
    error: 'Internal server error',
    requestId: req.id,
  });
});

module.exports = app;
```

### 2. NestJS Integration (`src/main.ts`)

```typescript
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import { Logger } from '@nestjs/common';
import { WinstonModule } from 'nest-winston';
import * as winston from 'winston';

async function bootstrap() {
  const app = await NestFactory.create(AppModule, {
    logger: WinstonModule.createLogger({
      level: 'info',
      format: winston.format.combine(
        winston.format.timestamp(),
        winston.format.json(),
      ),
      transports: [
        new winston.transports.Console(),
        new winston.transports.File({ filename: 'logs/error.log', level: 'error' }),
        new winston.transports.File({ filename: 'logs/combined.log' }),
      ],
    }),
  });

  await app.listen(3000);
}

bootstrap();
```

## ðŸ“Š Log Analysis

### 1. Log Aggregation (`src/utils/logAggregator.js`)

```javascript
const fs = require('fs');
const path = require('path');

class LogAggregator {
  constructor(logDir = 'logs') {
    this.logDir = logDir;
  }

  async getErrorStats(date = new Date()) {
    const dateStr = date.toISOString().split('T')[0];
    const errorLogFile = path.join(this.logDir, `error-${dateStr}.log`);
    
    if (!fs.existsSync(errorLogFile)) {
      return { totalErrors: 0, errorsByType: {}, errorsByHour: {} };
    }

    const content = fs.readFileSync(errorLogFile, 'utf8');
    const lines = content.split('\n').filter(line => line.trim());
    
    const stats = {
      totalErrors: lines.length,
      errorsByType: {},
      errorsByHour: {},
    };

    lines.forEach(line => {
      try {
        const log = JSON.parse(line);
        
        // Count by error type
        const errorType = log.error?.name || 'Unknown';
        stats.errorsByType[errorType] = (stats.errorsByType[errorType] || 0) + 1;
        
        // Count by hour
        const hour = new Date(log.timestamp).getHours();
        stats.errorsByHour[hour] = (stats.errorsByHour[hour] || 0) + 1;
      } catch (e) {
        // Skip invalid JSON lines
      }
    });

    return stats;
  }

  async getPerformanceStats(date = new Date()) {
    const dateStr = date.toISOString().split('T')[0];
    const logFile = path.join(this.logDir, `application-${dateStr}.log`);
    
    if (!fs.existsSync(logFile)) {
      return { totalOperations: 0, avgResponseTime: 0, slowOperations: [] };
    }

    const content = fs.readFileSync(logFile, 'utf8');
    const lines = content.split('\n').filter(line => line.trim());
    
    const operations = [];
    
    lines.forEach(line => {
      try {
        const log = JSON.parse(line);
        
        if (log.responseTime) {
          operations.push({
            operation: `${log.method} ${log.url}`,
            responseTime: parseInt(log.responseTime),
            timestamp: log.timestamp,
          });
        }
      } catch (e) {
        // Skip invalid JSON lines
      }
    });

    const totalOperations = operations.length;
    const avgResponseTime = totalOperations > 0 
      ? operations.reduce((sum, op) => sum + op.responseTime, 0) / totalOperations 
      : 0;
    
    const slowOperations = operations
      .filter(op => op.responseTime > 1000)
      .sort((a, b) => b.responseTime - a.responseTime)
      .slice(0, 10);

    return {
      totalOperations,
      avgResponseTime: Math.round(avgResponseTime),
      slowOperations,
    };
  }
}

module.exports = LogAggregator;
```

## ðŸš« Anti-Patterns to Avoid

1. **Logging Sensitive Data:**
   - **Bad:** Logging passwords, tokens, or PII.
   - **Good:** Sanitize logs and avoid sensitive information.

2. **Excessive Logging:**
   - **Bad:** Logging too much information in production.
   - **Good:** Use appropriate log levels and structured logging.

3. **Missing Context:**
   - **Bad:** Logs without request or user context.
   - **Good:** Always include relevant context in logs.

4. **Blocking Operations:**
   - **Bad:** Synchronous logging in hot paths.
   - **Good:** Use async logging and proper buffering.

5. **No Log Rotation:**
   - **Bad:** Letting log files grow indefinitely.
   - **Good:** Implement log rotation and retention policies.

## ðŸ§ª Testing Strategy

```javascript
// tests/logger.test.js
const loggerService = require('../src/services/loggerService');
const logger = require('../src/config/logger');

describe('LoggerService', () => {
  beforeEach(() => {
    // Clear context before each test
    loggerService.clearContext();
  });

  test('should set and clear context', () => {
    const context = { userId: '123', requestId: 'abc' };
    
    loggerService.setContext(context);
    expect(loggerService.context).toEqual(context);
    
    loggerService.clearContext();
    expect(loggerService.context).toEqual({});
  });

  test('should log with context', () => {
    const mockLog = jest.spyOn(logger, 'log');
    
    loggerService.setContext({ userId: '123' });
    loggerService.info('Test message', { action: 'test' });
    
    expect(mockLog).toHaveBeenCalledWith('info', 'Test message', {
      userId: '123',
      action: 'test',
    });
  });

  test('should log errors with stack trace', () => {
    const mockLog = jest.spyOn(logger, 'log');
    const error = new Error('Test error');
    
    loggerService.error('Test error message', error);
    
    expect(mockLog).toHaveBeenCalledWith('error', 'Test error message', {
      error: {
        message: 'Test error',
        stack: expect.any(String),
        name: 'Error',
      },
    });
  });

  test('should log performance metrics', () => {
    const mockLog = jest.spyOn(logger, 'log');
    
    loggerService.logPerformance('test_operation', 1500);
    
    expect(mockLog).toHaveBeenCalledWith('warn', 'Slow operation: test_operation', {
      operation: 'test_operation',
      duration: '1500ms',
    });
  });
});
```

## ðŸ“¦ Environment Variables

```env
# Logging Configuration
LOG_LEVEL=info
NODE_ENV=production

# File Logging
LOG_DIR=logs
LOG_MAX_SIZE=20m
LOG_MAX_FILES=14d

# Elasticsearch
ELASTICSEARCH_URL=http://localhost:9200
ELASTICSEARCH_INDEX=application-logs

# MongoDB Logging
MONGODB_LOG_URL=mongodb://localhost:27017/logs

# Log Rotation
LOG_DATE_PATTERN=YYYY-MM-DD
LOG_ZIPPED_ARCHIVE=true
```

## ðŸ“¦ Package.json Scripts

```json
{
  "scripts": {
    "logs:tail": "tail -f logs/application-$(date +%Y-%m-%d).log",
    "logs:errors": "tail -f logs/error-$(date +%Y-%m-%d).log",
    "logs:analyze": "node src/utils/logAnalyzer.js",
    "logs:clean": "find logs -name '*.log' -mtime +30 -delete",
    "logs:rotate": "logrotate /etc/logrotate.d/myapp"
  }
}
```
