# Express.js Documentation

> **Purpose:** Fast, unopinionated, minimalist web framework for Node.js.

## ðŸ“¦ Installation

```bash
npm install express
npm install -D @types/express typescript ts-node nodemon
```

## ðŸ› ï¸ Basic Setup

**Strategy:** We use a modular approach with separate files for routes, middleware, and configuration.

### 1. Main Server File (`src/server.ts`)

```typescript
import express from 'express';
import cors from 'cors';
import helmet from 'helmet';
import compression from 'compression';
import { errorHandler } from './middleware/errorHandler';
import { notFoundHandler } from './middleware/notFoundHandler';
import { authRoutes } from './routes/auth';
import { userRoutes } from './routes/users';

const app = express();

// ðŸ”’ Security Middleware
app.use(helmet());
app.use(cors({
  origin: process.env.FRONTEND_URL || 'http://localhost:3000',
  credentials: true,
}));

// ðŸ“¦ Body Parsing Middleware
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true }));
app.use(compression());

// ðŸ›¡ï¸ Request Logging
{% if "Winston" in libraries %}
import { logger } from './utils/logger';
app.use((req, res, next) => {
  logger.info(`${req.method} ${req.path}`, {
    ip: req.ip,
    userAgent: req.get('User-Agent'),
  });
  next();
});
{% endif %}

// ðŸš€ API Routes
app.use('/api/auth', authRoutes);
app.use('/api/users', userRoutes);

// ðŸŽ¯ Health Check
app.get('/health', (req, res) => {
  res.status(200).json({
    status: 'OK',
    timestamp: new Date().toISOString(),
    uptime: process.uptime(),
  });
});

// âŒ Error Handlers (Must be last)
app.use(notFoundHandler);
app.use(errorHandler);

export { app };
```

### 2. Server Entry Point (`src/index.ts`)

```typescript
import { app } from './server';
{% if "Winston" in libraries %}
import { logger } from './utils/logger';
{% endif %}

const PORT = process.env.PORT || 5000;

const server = app.listen(PORT, () => {
  {% if "Winston" in libraries %}
  logger.info(`Server running on port ${PORT}`);
  {% else %}
  console.log(`Server running on port ${PORT}`);
  {% endif %}
});

// Graceful Shutdown
process.on('SIGTERM', () => {
  {% if "Winston" in libraries %}
  logger.info('SIGTERM received, shutting down gracefully');
  {% else %}
  console.log('SIGTERM received, shutting down gracefully');
  {% endif %}
  server.close(() => {
    process.exit(0);
  });
});
```

## ðŸ›¡ï¸ Error Handling

### 1. Not Found Handler (`src/middleware/notFoundHandler.ts`)

```typescript
import { Request, Response } from 'express';

export const notFoundHandler = (req: Request, res: Response) => {
  res.status(404).json({
    success: false,
    message: `Route ${req.originalUrl} not found`,
  });
};
```

### 2. Error Handler (`src/middleware/errorHandler.ts`)

```typescript
import { Request, Response, NextFunction } from 'express';

export interface CustomError extends Error {
  statusCode?: number;
  isOperational?: boolean;
}

export const errorHandler = (
  err: CustomError,
  req: Request,
  res: Response,
  next: NextFunction
) => {
  let error = { ...err };
  error.message = err.message;

  // Log error
  {% if "Winston" in libraries %}
  logger.error(err);
  {% else %}
  console.error(err);
  {% endif %}

  // Mongoose bad ObjectId
  if (err.name === 'CastError') {
    const message = 'Resource not found';
    error = { name: 'CastError', message, statusCode: 404 };
  }

  // Mongoose duplicate key
  if (err.name === 'MongoError' && (err as any).code === 11000) {
    const message = 'Duplicate field value entered';
    error = { name: 'MongoError', message, statusCode: 400 };
  }

  // Mongoose validation error
  if (err.name === 'ValidationError') {
    const message = Object.values((err as any).errors).map((val: any) => val.message).join(', ');
    error = { name: 'ValidationError', message, statusCode: 400 };
  }

  res.status(error.statusCode || 500).json({
    success: false,
    message: error.message || 'Server Error',
  });
};
```

## ðŸš€ Route Structure

### 1. Auth Routes (`src/routes/auth.ts`)

```typescript
import { Router } from 'express';
import { register, login, logout, getMe } from '../controllers/auth';
import { protect } from '../middleware/auth';

const router = Router();

router.post('/register', register);
router.post('/login', login);
router.post('/logout', logout);
router.get('/me', protect, getMe);

export { router as authRoutes };
```

### 2. Controller (`src/controllers/auth.ts`)

```typescript
import { Response, NextFunction } from 'express';
import { User } from '../models/User';
import { asyncHandler } from '../utils/asyncHandler';
import { AuthenticatedRequest } from '../types';

// @desc    Register user
// @route   POST /api/auth/register
export const register = asyncHandler(async (req: AuthenticatedRequest, res: Response) => {
  const { name, email, password } = req.body;

  // Create user
  const user = await User.create({
    name,
    email,
    password,
  });

  sendTokenResponse(user, 201, res);
});

// @desc    Login user
// @route   POST /api/auth/login
export const login = asyncHandler(async (req: AuthenticatedRequest, res: Response) => {
  const { email, password } = req.body;

  // Validate email & password
  if (!email || !password) {
    return res.status(400).json({
      success: false,
      message: 'Please provide an email and password',
    });
  }

  // Check for user
  const user = await User.findOne({ email }).select('+password');

  if (!user) {
    return res.status(401).json({
      success: false,
      message: 'Invalid credentials',
    });
  }

  // Check if password matches
  const isMatch = await user.matchPassword(password);

  if (!isMatch) {
    return res.status(401).json({
      success: false,
      message: 'Invalid credentials',
    });
  }

  sendTokenResponse(user, 200, res);
});
```

## ðŸ›¡ï¸ Authentication Middleware

### 1. Auth Middleware (`src/middleware/auth.ts`)

```typescript
import { Response, NextFunction } from 'express';
import jwt from 'jsonwebtoken';
import { User } from '../models/User';
import { AuthenticatedRequest } from '../types';

export const protect = async (
  req: AuthenticatedRequest,
  res: Response,
  next: NextFunction
) => {
  let token;

  if (req.headers.authorization && req.headers.authorization.startsWith('Bearer')) {
    token = req.headers.authorization.split(' ')[1];
  }

  if (!token) {
    return res.status(401).json({
      success: false,
      message: 'Not authorized to access this route',
    });
  }

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET!) as any;
    req.user = await User.findById(decoded.id);
    next();
  } catch (err) {
    return res.status(401).json({
      success: false,
      message: 'Not authorized to access this route',
    });
  }
};
```

## ðŸš« Anti-Patterns to Avoid

1. **Callback Hell:**
   - **Bad:** Using nested callbacks instead of async/await.
   - **Good:** Use async/await with proper error handling.

2. **Global Variables:**
   - **Bad:** Storing state in global variables.
   - **Good:** Use middleware or dependency injection.

3. **Sync Operations:**
   - **Bad:** Using synchronous file operations in production.
   - **Good:** Use async versions of all I/O operations.

4. **Missing Error Handling:**
   - **Bad:** Not handling promise rejections.
   - **Good:** Always use try/catch or error handling middleware.

5. **Hardcoded Configuration:**
   - **Bad:** Hardcoding ports, URLs, or secrets.
   - **Good:** Use environment variables.

## ðŸ§ª Testing Strategy

{% if "Jest" in libraries %}
Use Jest for testing Express.js applications:

```typescript
// tests/auth.test.ts
import request from 'supertest';
import { app } from '../src/server';

describe('Auth Routes', () => {
  test('POST /api/auth/register', async () => {
    const res = await request(app)
      .post('/api/auth/register')
      .send({
        name: 'Test User',
        email: 'test@example.com',
        password: 'password123',
      });

    expect(res.statusCode).toEqual(201);
    expect(res.body).toHaveProperty('token');
  });
});
```
{% endif %}

## ðŸ“¦ Package.json Scripts

```json
{
  "scripts": {
    "dev": "nodemon src/index.ts",
    "build": "tsc",
    "start": "node dist/index.js",
    "test": "jest",
    "test:watch": "jest --watch"
  }
}
```
